Para saber cómo funciona el entorno de desarrollo y el compilador elegidos —o mejor dicho, para saber qué falla cuando no funcionan— es importante saber cómo se llega desde el programa “Hola mundo!” de más arriba a teclear “helloworld0” (que es como llamaremos al ejecutable) y ver cómo nuestro esfuerzo (y el del compilador) se ven recompensados con una línea de saludo en la consola, producida por nuestro programa.

En la figura 2a.2 se muestra un diagrama de bloques con el flujo de información que se produce. Partimos de un archivo de texto “helloworld0.c”, en codificación ASCII o, lo que se suele llamar “texto plano”; este archivo contiene el código con la sintaxis C (esperamos que correcta) que hemos escrito. Cuando llamamos al compilador sólo le decimos el nombre de este archivo de código y el nombre del ejecutable que queremos que produca (“helloworld0” en Linux, “helloworld0.exe” en Windows). Al decirle esto, “gcc” comienza una cascada de operaciones concatenadas unas con otras: preprocesamiento, “parsing” o interpretación, com- pilación y enlazado.


1. El preprocesamiento lo realiza el preprocesador, un programa llamado “cpp” (C PrePro- cessor). Se encarga de interpretar unas “directivas” sencillas (que no constituyen un Física Computacional I. M. Arias, P. Córdoba, D. Rodríguez, P.Martinez-Legazpi. Dep. Física Matemática y de Fluidos. UNED, 2024 2a-6 TEMA 2A. PROGRAMAS INFORMÁTICOS lenguaje en sí mismas, sino una especie de reglas de sustitución) que aparecen mar- cadas como líneas que empiezan por “#”. Un ejemplo en nuestro primer programa es la primera línea: #include <stdio.h>. Esta línea incluye todo el código que existe en el archivo de “cabeceras” (o archivo H, de “header”), previamente interpretado por el pro- pio preprocesador “cpp”. En los archivos H se declaran las funciones disponibles para ser usadas en nuestro programa; en particular, la función “printf”. Sin el archivo H, el compilador no sabría cuantos o de qué tipo son los argumentos que espera la función “printf”. Veremos más adelante otras directivas del preprocesador muy útiles.

2. El “parsing” o interpretación de la sintaxis consiste en identificar las palabras clave del lenguaje (como “int” o “return”), los limitadores de ámbito (las “llaves”), las variables y funciones (como “main” o “printf”), los literales (como la cadena, entrecomillada, “Hola mundo!\n”), etc. Cualquier error, como la falta de un simple “;” al final de una línea, detendrá el proceso, ya que el código puede ser ambiguo. 

3. La compilación consiste en, una vez identificada la estructura del programa, las estruc- turas de control en él, las funciones, las variables, las operaciones, etc. traducir éstas a instrucciones que entendería el procesador de nuestra máquina. Esto generaría (si lo guardásemos en el disco duro) un archivo “objeto” (con extensión O) que contiene todas las instrucciones correspondientes a lo que nosotros hemos escrito; nada más. 

4. El enlazado sirve para unir nuestro “objeto” con otros “objetos” para construir un ejecu- table. Esto lo lleva a cabo el programa “ld”. Los objetos que une al nuestro son los que indican al sistema operativo, por ejemplo, cuál es la primera función que se ejecutará (main, en todos nuestros programas en C), o los objetos que proveen algunas funciones que nosotros no hemos escrito, o las “bibliotecas de funciones” (de enlace dinámico) que contienen otras de las funciones que nosotros llamamos; por ejemplo, la función “printf” se encuentra, en Linux, en la biblioteca “/lib/libc.so”, y en Windows en la “c:\Windows\System32\MSCRT.DLL”. Más adelante veremos que, cuando empleemos una función matemática como la raíz cuadrada, “sqrt”, deberemos decirle al GCC dónde en- contrarla (para que se lo indique al “linker”): añadiremos la opción “-lm”, que significa que la biblioteca de enlace dinámico se encuentra en un archivo llamado “libm.so”, en alguna parte (convenida) de nuestro sistema de ficheros.

El programa “gcc” realiza todas estas operaciones él solo, por lo que se le llama siempre “el compilador” (la operación que no hace otro programa como “cpp” o “ld”). Es muy importante tener en cuenta un detalle de cómo se llevan a cabo todas estas etapas: una justo a continuación de otra. Esto significa que, según el preprocesador completa la “tra- ducción” de una línea, se la pasa al “parser”; cuando el “parser” encuentra una instrucción en C completa, se la pasa al compilador propiamente dicho; cuando el compilador genera las ins- trucciones binarias que equivalen a esa instrucción en C, las añade a un “objeto” (que guarda en un archivo temporal). Cuando el objeto está completo, el “linker” lo une, indexa y referencia con los demás objetos, produciendo, finalmente, el ejecutable. Este flujo continuado diferencia al C de otros lenguajes porque obliga, por ejemplo, a declarar todo lo que se va a utilizar antes de utilizarlo, como el caso de la función “printf”, que está declarada en “stdio.h” como extern int printf (const char *format, ...);

Pronto veremos que todas las funciones y variables que se vayan a emplear deberán haber sido previamente declaradas. A continuación sigue una sección práctica para hacer todas estas operaciones de varias maneras, y ganar familiaridad con las herramientas.

#C


